<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Territory Mapper Pro (v14.2)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  html, body, #map { height:100%; margin:0; }

  /* Panel */
  #panel {
    position:fixed; top:20px; left:20px; z-index:9999; background:#fff;
    padding:0; border:1px solid #ccc; border-radius:10px;
    box-shadow:0 2px 6px rgba(0,0,0,0.15);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    font-size:13px; width:360px; max-height:86vh; overflow:hidden;
  }
  #panelHeader {
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px; border-bottom:1px solid #e6e6e6; background:#f7f7f9;
  }
  #panelHeader .badge { background:#ffe08a; color:#7a4d00; font-weight:700; padding:2px 6px; border-radius:6px; }
  #panelHeader .title { font-weight:700; font-size:14px; display:flex; align-items:center; gap:8px; }
  #btnCollapsePanel { cursor:pointer; border:1px solid #fff; border-radius:6px; background:#6a1b9a; padding:2px 6px; font-size:12px; }

  #panelBody { padding:12px; overflow:auto; max-height:calc(86vh - 40px); }
  #panel.is-collapsed #panelBody { display:none; }
  #panel.is-collapsed { max-height:unset; }

  /* Tabs for AI Tools */
  .tabs {
    display:flex; gap:4px; margin-bottom:12px; border-bottom:2px solid #e6e6e6;
  }
  .tab {
    padding:8px 12px; cursor:pointer; border-radius:8px 8px 0 0;
    background:#f0f0f3; transition:all 0.2s; font-weight:500;
  }
  .tab:hover { background:#e6e6e9; }
  .tab.active {
    background:#6a1b9a; color:#fff;
  }
  .tab-content { display:none; }
  .tab-content.active { display:block; }

  /* Insights Panel - always visible */
  #insightsPanel {
    position:fixed; top:20px; right:20px; z-index:9998;
    width:320px; background:#fff;
    border:1px solid #ccc; border-radius:10px;
    box-shadow:0 2px 6px rgba(0,0,0,0.15);
    font-family:system-ui, -apple-system, sans-serif;
    font-size:13px;
    transition: all 0.3s ease;
  }
  #insightsPanel.highlighted {
    box-shadow:0 0 12px rgba(106, 27, 154, 0.4);
    border-color:#6a1b9a;
  }
  #insightsHeader {
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px; border-bottom:1px solid #e6e6e6; 
    background:#f7f7f9; border-radius:10px 10px 0 0;
  }
  #insightsHeader.has-update {
    background:linear-gradient(135deg, #f7f7f9 0%, #f0e6ff 100%);
  }
  #insightsBody {
    padding:12px; max-height:400px; overflow:auto;
  }
  #btnCollapseInsights {
    cursor:pointer; border:1px solid #fff; border-radius:6px; 
    background:#6a1b9a; padding:2px 6px; font-size:12px; color:#fff;
  }
  #insightsPanel.is-collapsed #insightsBody { display:none; }
  #insightsPanel.is-collapsed { max-height:unset; }
  
  /* AI Assistant Panel */
  #aiPanel {
    position:fixed; top:460px; right:20px; z-index:9997;
    width:320px; height:360px; background:#fff;
    border:1px solid #ccc; border-radius:10px;
    box-shadow:0 2px 6px rgba(0,0,0,0.15);
    font-family:system-ui, -apple-system, sans-serif;
    display:none; flex-direction:column;
  }
  #aiPanel.active { display:flex; }
  
  #aiHeader {
    display:flex; align-items:center; justify-content:space-between;
    padding:10px 14px; border-bottom:1px solid #e6e6e6;
    background:linear-gradient(135deg, #6a1b9a 0%, #8e24aa 100%);
    color:#fff; border-radius:10px 10px 0 0;
  }
  
  #aiChat {
    flex:1; overflow-y:auto; padding:12px;
    background:#f9f9fb;
  }
  
  .ai-message {
    margin:8px 0; padding:8px 12px; border-radius:12px;
    max-width:85%; word-wrap:break-word;
  }
  .ai-message.user {
    background:#6a1b9a; color:#fff; margin-left:auto;
    text-align:right;
  }
  .ai-message.assistant {
    background:#fff; border:1px solid #e0e0e0;
  }
  
  #aiInputArea {
    padding:10px; border-top:1px solid #e6e6e6;
    display:flex; gap:8px;
  }
  
  #aiInput {
    flex:1; padding:8px; border:1px solid #ddd;
    border-radius:20px; font-size:13px;
  }
  
  #aiSend {
    padding:8px 16px; background:#6a1b9a; color:#fff;
    border:none; border-radius:20px; cursor:pointer;
    font-weight:500;
  }
  #aiSend:hover { background:#8e24aa; }
  
  /* AI Analysis Results */
  .ai-analysis-card {
    background:#fff; border:1px solid #e0e0e0;
    border-radius:8px; padding:10px; margin:8px 0;
  }
  .ai-stat {
    display:flex; justify-content:space-between;
    padding:4px 0; border-bottom:1px solid #f0f0f0;
  }
  .ai-stat:last-child { border-bottom:none; }
  .ai-recommendation {
    background:#f0f8ff; padding:8px; border-radius:6px;
    margin-top:8px; border-left:3px solid #1f77b4;
  }

  /* Brand buttons */
  button {
    background:#6a1b9a;
    color:#fff;
    border:none;
    border-radius:6px;
    padding:4px 8px;
    font-weight:500;
    cursor:pointer;
    transition:background .2s;
  }
  button:hover {
    background:#8e24aa;
  }
  button:disabled {
    background:#ccc;
    color:#666;
    cursor:default;
  }

  /* AI Toggle Button */
  #btnToggleAI {
    position:fixed; bottom:80px; right:20px; z-index:9999;
    width:56px; height:56px; border-radius:50%;
    background:linear-gradient(135deg, #6a1b9a 0%, #8e24aa 100%);
    color:#fff; border:none; box-shadow:0 3px 8px rgba(0,0,0,0.2);
    display:flex; align-items:center; justify-content:center;
    font-size:24px; cursor:pointer; transition:transform 0.2s;
  }
  #btnToggleAI:hover { transform:scale(1.1); }

  /* Legend */
  #legend {
    position:fixed; bottom:20px; left:20px; z-index:9998; background:#fff;
    padding:10px 12px; border:1px solid #ccc; border-radius:10px;
    box-shadow:0 2px 6px rgba(0,0,0,0.15); font-family:system-ui; font-size:13px;
  }
  .swatch{display:inline-block;width:12px;height:12px;border-radius:50%;margin-right:6px;vertical-align:-2px;}
  .list-item{padding:6px 8px;border-bottom:1px solid #eee;cursor:pointer;}
  .list-item:hover{background:#f6f8fa;}
  .leaflet-interactive.territory-boundary{pointer-events:none;}
  .muted{color:#666;}
  .row{display:flex;gap:6px;}
  .row>*{flex:1;}
  .popup-row{margin-top:6px}
  .popup-row select{padding:2px 4px; font-size:12px;}
  
  /* Enhanced popup styling */
  .leaflet-popup-content {
    min-width:250px;
    max-width:350px;
  }
  .leaflet-popup-content textarea {
    font-family:system-ui, -apple-system, sans-serif;
  }
  .leaflet-popup-content button[data-role="save-changes"] {
    background:#6a1b9a;
    color:#fff;
    border:none;
    border-radius:6px;
    padding:6px 12px;
    font-weight:500;
    cursor:pointer;
    font-size:13px;
    transition:background .2s;
  }
  .leaflet-popup-content button[data-role="save-changes"]:hover:not(:disabled) {
    background:#8e24aa;
  }
  .leaflet-popup-content button[data-role="save-changes"]:disabled {
    background:#ccc;
    color:#666;
    cursor:default;
  }
  .leaflet-popup-content button[data-role="add-timestamp"] {
    background:#f0f0f3;
    color:#333;
    border:1px solid #ddd;
    cursor:pointer;
    transition:background .2s;
  }
  .leaflet-popup-content button[data-role="add-timestamp"]:hover {
    background:#e6e6e9;
  }

  /* Toast */
  #toast {
    position:fixed;right:20px;bottom:20px;z-index:10000;
    padding:10px 12px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,.15);
    font:13px/1.3 system-ui;display:none;max-width:50vw;
  }

  /* Log (minimizable, doesn't cover legend) */
  #log {
    position:fixed; right:20px; bottom:150px; z-index:10000;
    min-width:260px; max-width:45vw; max-height:30vh; overflow:auto;
    border-radius:8px; border:1px solid #e0e0e0; background:#fafafa; color:#333;
    font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }
  #logHeader { display:flex; align-items:center; justify-content:space-between; padding:6px 8px; background:#f0f0f3; border-bottom:1px solid #e0e0e0; }
  #logBody { padding:6px 8px; }
  #btnToggleLog { border:1px solid #ccc; border-radius:6px; background:#6a1b9a; padding:2px 6px; font-size:12px; cursor:pointer; }

  @media (max-width: 600px) {
    #panel { width:92vw; left:4vw; top:12px; }
    #panelBody { max-height:calc(70vh - 40px); }
    #legend { left:12px; bottom:12px; }
    #toast { right:12px; bottom:12px; max-width:75vw; }
    #log { right:12px; bottom:150px; max-width:75vw; }
    #insightsPanel { width:90vw; right:5vw; top:auto; bottom:160px; }
    #aiPanel { width:90vw; right:5vw; height:60vh; top:auto; bottom:250px; }
  }
</style>
</head>
<body>
<div id="map"></div>

<div id="panel">
<div id="panelHeader">
  <div class="title">
    <img src="madscience-logo.png" alt="Mad Science" style="height:28px; margin-right:8px;">
    <span>Control Panel</span>
    <span class="badge">v14.2</span>
  </div>
  <button id="btnCollapsePanel" title="Collapse/Expand">Collapse</button>
</div>

  <div id="panelBody">
    <!-- Tabs for Filters and AI Tools only -->
    <div class="tabs">
      <div class="tab active" data-tab="filters">Filters</div>
      <div class="tab" data-tab="ai-tools">AI Tools</div>
    </div>

    <!-- Filters Tab (Original Content) -->
    <div id="filters-content" class="tab-content active">
      <div class="filter-block" style="margin-bottom:8px;">
        <label for="territorySel"><strong>Territory:</strong></label><br>
        <select id="territorySel">
          <option value="">-- Select a territory --</option>
        </select>
      </div>

      <div style="margin-bottom:8px;">
        <div style="font-weight:600; margin-bottom:4px;">Status</div>
        <label><input type="checkbox" class="statusChk" value="none" checked> None</label><br>
        <label><input type="checkbox" class="statusChk" value="recent" checked> Recent</label><br>
        <label><input type="checkbox" class="statusChk" value="inprogress" checked> In Progress</label><br>
        <label><input type="checkbox" class="statusChk" value="current" checked> Current</label>
      </div>

      <div style="margin-bottom:8px;">
        <label style="font-weight:600;">
          <input type="checkbox" id="showStaffChk" checked> Show Staff Locations
        </label>
      </div>

      <div style="margin-bottom:8px;">
        <div style="font-weight:600; margin-bottom:4px;">Group</div>
        <select id="groupSel" multiple size="7" style="width:100%;"></select>
        <div class="row" style="margin-top:6px;">
          <button id="groupClear" type="button">Clear</button>
          <button id="groupSelectAll" type="button">Select all</button>
          <button id="btnToggleList" type="button">List View: OFF</button>
        </div>
      </div>

      <div style="margin-bottom:8px;">
        <div style="font-weight:600; margin-bottom:4px;">Search</div>
        <input id="searchBox" type="text" placeholder="Name, address, or notes..." style="width:100%; padding:6px;">
        <div class="row" style="margin-top:6px;">
          <button id="btnSearch" type="button">Apply</button>
          <button id="btnClearSearch" type="button">Clear</button>
          <button id="btnZoomFirst" type="button">Zoom to first</button>
        </div>
      </div>

      <div id="listContainer" style="display:none; margin:10px 0; border:1px solid #ddd; border-radius:8px; max-height:220px; overflow:auto;">
        <div style="padding:6px 8px; font-weight:600; border-bottom:1px solid #eee;">Locations</div>
        <div id="schoolList" style="max-height:180px; overflow:auto;"></div>
      </div>

      <hr style="margin:10px 0;">

      <div class="row" style="align-items:center; flex-wrap:wrap;">
        <button id="btnDownloadAll" type="button" style="font-weight:700;">Download CSV (All)</button>
        <button id="btnDownloadFiltered" type="button" style="font-weight:700;">Download Filtered CSV</button>
      </div>
    </div>

    <!-- AI Tools Tab -->
    <div id="ai-tools-content" class="tab-content">
      <div style="margin-bottom:12px;">
        <div style="font-weight:600; margin-bottom:6px;">🤖 AI Assistant</div>
        <button id="btnOpenAI" type="button" style="width:100%;">Open Chat Assistant</button>
        <div style="font-size:11px; color:#666; margin-top:4px;">Ask questions about your data in natural language</div>
      </div>

      <div style="margin-bottom:12px;">
        <div style="font-weight:600; margin-bottom:6px;">🔍 Advanced Search</div>
        <input id="aiSearchBox" type="text" placeholder="Try: 'uncontacted', 'with notes', 'in progress'..." style="width:100%; padding:6px; margin-bottom:6px;">
        <button id="btnAISearch" type="button" style="width:100%;">Search with Keywords</button>
        <div style="font-size:11px; color:#666; margin-top:4px;">Searches status, notes, and all fields with smart matching</div>
      </div>

      <div style="margin-bottom:12px;">
        <div style="font-weight:600; margin-bottom:6px;">📊 Quick Analysis</div>
        <button id="btnAnalyzeTerritory" type="button" style="width:100%; margin-bottom:4px;">Analyze Current View</button>
        <button id="btnPredictGrowth" type="button" style="width:100%;">Predict Growth Potential</button>
      </div>

      <div style="margin-bottom:12px;">
        <div style="font-weight:600; margin-bottom:6px;">📈 Reports</div>
        <button id="btnGenerateReport" type="button" style="width:100%;">Generate Analysis Report</button>
        <div style="font-size:11px; color:#666; margin-top:4px;">Creates a downloadable report with insights</div>
      </div>
    </div>
  </div>
</div>

<!-- Insights Panel (Always Visible) -->
<div id="insightsPanel">
  <div id="insightsHeader">
    <div style="font-weight:700; font-size:14px;">📊 Live Insights</div>
    <button id="btnCollapseInsights" title="Collapse/Expand">Collapse</button>
  </div>
  <div id="insightsBody">
    <div class="ai-analysis-card">
      <h4 style="margin:0 0 8px 0;">Overview</h4>
      <div id="territoryStats"></div>
    </div>
    <div class="ai-analysis-card">
      <h4 style="margin:0 0 8px 0;">AI Recommendations</h4>
      <div id="aiRecommendations"></div>
    </div>
  </div>
</div>

<!-- AI Assistant Panel -->
<div id="aiPanel">
  <div id="aiHeader">
    <strong>🤖 AI Assistant</strong>
    <button id="btnCloseAI" style="background:transparent; border:1px solid #fff; color:#fff;">✕</button>
  </div>
  <div id="aiChat"></div>
  <div id="aiInputArea">
    <input id="aiInput" type="text" placeholder="Ask about schools, territories, or strategies...">
    <button id="aiSend">Send</button>
  </div>
</div>

<!-- AI Toggle Button -->
<button id="btnToggleAI" title="Toggle AI Assistant">🤖</button>

<div id="legend">
  <div style="font-weight:700; margin-bottom:6px;">Status Legend</div>
  <div><span class="swatch" style="background:#808080;"></span> None</div>
  <div><span class="swatch" style="background:#1f77b4;"></span> Recent</div>
  <div><span class="swatch" style="background:#ff7f0e;"></span> In Progress</div>
  <div><span class="swatch" style="background:#2ca02c;"></span> Current</div>
  <div><span class="swatch" style="background:#800080;"></span> Staff</div>
</div>

<div id="toast"></div>

<div id="log">
  <div id="logHeader">
    <strong>Log</strong>
    <button id="btnToggleLog" aria-expanded="true">Minimize</button>
  </div>
  <div id="logBody"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ===== CONFIG — SET THESE ===== */
const SHEETS_ENDPOINT = "https://script.google.com/macros/s/AKfycbwLziNp4LZSh1CMl0KcbjCZDM5d1TlX8BaAqT8A2uBd5eiHUEwVmYFNDMhM6G51Ele-lQ/exec";  // GET CSV data
const WRITE_ENDPOINT  = "https://script.google.com/macros/s/AKfycbwLziNp4LZSh1CMl0KcbjCZDM5d1TlX8BaAqT8A2uBd5eiHUEwVmYFNDMhM6G51Ele-lQ/exec";  // POST updates
const WRITE_SECRET    = "123456pooydiapers";  // Authentication key
const SHEET_TAB_NAME  = "Sheet1";  // Google Sheets tab name
const TERRITORIES_URL = "territories.json";  // Territory boundaries file
const COLOR = { none:"#808080", recent:"#1f77b4", current:"#2ca02c", inprogress:"#ff7f0e", staff:"#800080" };

/* ===== Map ===== */
const map = L.map('map').setView([45.2, -62.99], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

/* ===== Log/Toast ===== */
function log(msg){
  const el=document.getElementById('logBody');
  const t=new Date().toLocaleTimeString();
  el.insertAdjacentHTML('beforeend', `<div><b>${t}</b> ${msg}</div>`);
  el.scrollTop=el.scrollHeight;
}
function showToast(msg, kind='ok'){
  const t=document.getElementById('toast');
  if(kind==='error'){t.style.background='#fdecea';t.style.border='1px solid #f5c2c0';t.style.color='#b71c1c';}
  else {t.style.background='#e8f5e9';t.style.border='1px solid #c8e6c9';t.style.color='#2e7d32';}
  t.textContent=msg; t.style.display='block'; clearTimeout(t._hideTimer);
  t._hideTimer=setTimeout(()=>{t.style.display='none';},3200);
}

/* Log minimize */
document.getElementById('btnToggleLog').addEventListener('click',()=>{
  const btn = document.getElementById('btnToggleLog');
  const body= document.getElementById('logBody');
  const isOpen = btn.getAttribute('aria-expanded') === 'true';
  if(isOpen){ body.style.display='none'; btn.textContent='Expand'; btn.setAttribute('aria-expanded','false'); }
  else { body.style.display='block'; btn.textContent='Minimize'; btn.setAttribute('aria-expanded','true'); }
});

/* Panel collapse (session-persisted) */
(function setupPanelCollapse(){
  const panel = document.getElementById('panel');
  const btn = document.getElementById('btnCollapsePanel');
  const KEY = 'panelCollapsed';
  function apply(state){ panel.classList.toggle('is-collapsed', !!state); btn.textContent = state ? 'Expand' : 'Collapse'; btn.setAttribute('aria-expanded', String(!state)); }
  const saved = sessionStorage.getItem(KEY) === '1';
  apply(saved);
  btn.addEventListener('click',()=>{
    const newState = !panel.classList.contains('is-collapsed');
    sessionStorage.setItem(KEY, newState ? '1' : '0');
    apply(newState);
  });
})();

/* Safety */
window.addEventListener('error', (e)=>{ log('Error: '+ (e && e.message ? e.message : e)); showToast('JS error: '+(e && e.message ? e.message : 'unknown'), 'error'); });
window.addEventListener('unhandledrejection', (e)=>{ log('Promise rejection: '+ (e && e.reason ? e.reason : e)); showToast('Unhandled rejection', 'error'); });

/* Utilities */
async function fetchWithTimeout(url, options={}, ms=15000){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), ms);
  try{ return await fetch(url, { ...options, signal: ctrl.signal }); }
  finally{ clearTimeout(id); }
}

/* CSV */
function splitCSVLine(line){const out=[];let cur='',q=false;for(let i=0;i<line.length;i++){const c=line[i];if(c==='"'){if(q&&line[i+1]==='"'){cur+='"';i++}else q=!q}else if(c===','&&!q){out.push(cur);cur=''}else cur+=c}out.push(cur);return out}
function parseCSV(text){const clean=text.replace(/^\uFEFF/,'').replace(/\r\n/g,'\n');const lines=clean.split('\n').filter(l=>l.trim());if(!lines.length)return{header:[],rows:[]};const header=splitCSVLine(lines[0]).map(h=>h.trim());const rows=lines.slice(1).map(line=>{const cols=splitCSVLine(line);const rec={};header.forEach((h,i)=>rec[h]=(cols[i]??'').trim());return rec});return{header,rows}}

/* Geometry */
function bboxOfRing(r){let w=Infinity,s=Infinity,e=-Infinity,n=-Infinity;for(const[lon,lat]of r){if(lon<w)w=lon;if(lon>e)e=lon;if(lat<s)s=lat;if(lat>n)n=lat}return[w,s,e,n]}
function expandBBox(b,a){if(!b)return a.slice();if(a[0]<b[0])b[0]=a[0];if(a[1]<b[1])b[1]=a[1];if(a[2]>b[2])b[2]=a[2];if(a[3]>b[3])b[3]=a[3];return b}
function bboxOfPolygon(p){return bboxOfRing(p[0])}
function bboxOfGeometry(g){if(!g)return null;if(g.type==='Polygon')return bboxOfPolygon(g.coordinates);if(g.type==='MultiPolygon'){let b=null;for(const p of g.coordinates)b=expandBBox(b,bboxOfPolygon(p));return b}return null}
function pointInRing(x,y,ring){let inside=false;for(let i=0,j=ring.length-1;i<ring.length;j=i++){const[xi,yi]=ring[i],[xj,yj]=ring[j];const inter=((yi>y)!=(yj>y))&&(x<(xj-xi)*(y-yi)/((yj-yi)||1e-12)+xi);if(inter)inside=!inside}return inside}
function pointInGeometry(x,y,g){if(!g)return false;if(g.type==='Polygon'){const r=g.coordinates;if(!pointInRing(x,y,r[0]))return false;for(let i=1;i<r.length;i++)if(pointInRing(x,y,r[i]))return false;return true}if(g.type==='MultiPolygon'){for(const p of g.coordinates){const r=p;if(!pointInRing(x,y,r[0]))continue;let ok=true;for(let i=1;i<r.length;i++)if(pointInRing(x,y,r[i])){ok=false;break}if(ok)return true}}return false}

/* State */
let DATA=[], HEADER=[], markers=[], LIST_ON=false;
let GROUPS=[], TERRITORIES=[], currentTerritory=null, territoryLayer=null;

/* Normalize */
function normalizeRecords(rows){
  const latKeys=['lat','Lat','LAT','latitude','Latitude','LATITUDE','y','Y'];
  const lonKeys=['lon','Lon','LON','lng','Lng','LNG','long','Long','LONG','longitude','Longitude','LONGITUDE','x','X'];
  rows.forEach(r=>{
    let lat=null,lon=null;
    for(const k of latKeys) if(r[k]&&lat===null){const v=parseFloat(r[k]); if(Number.isFinite(v)) lat=v}
    for(const k of lonKeys) if(r[k]&&lon===null){const v=parseFloat(r[k]); if(Number.isFinite(v)) lon=v}
    if(Number.isFinite(lat)) r.lat=lat;
    if(Number.isFinite(lon)) r.lon=lon;
    const raw=(r.active??r.Active??r.ACTIVE??'').toString().trim().toUpperCase();
    r.active = raw==='' ? true : !(raw==='FALSE'||raw==='0'||raw==='NO'||raw==='N');
    if(r.Id && !Number.isFinite(r.Id)){const n=parseFloat(r.Id); if(Number.isFinite(n)) r.Id=n}
    // Initialize Notes field if it doesn't exist
    if(r.Notes === undefined && r.notes === undefined) r.Notes = '';
  });
}
function isValidLatLon(lat,lon){return Number.isFinite(lat)&&Number.isFinite(lon)&&lat>=-90&&lat<=90&&lon>=-180&&lon<=180}
function normalizeStatus(s){s=(s||'').toLowerCase().trim(); if(!['none','recent','inprogress','current','staff'].includes(s)) s='none'; return s}
function getStatusColor(r){return COLOR[normalizeStatus(r.Status||r.status)]||COLOR.none}

/* Territories */
async function loadTerritories(){
  const res = await fetch(TERRITORIES_URL, {cache:'no-store'});
  if(!res.ok) throw new Error('Territories HTTP '+res.status);
  const list = await res.json();
  TERRITORIES = Array.isArray(list)? list : [];
  TERRITORIES.forEach(t=>{ if(!t.id){t.id=(t.name||'territory').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-|-$/g,'')} if(!t.bbox) t.bbox=bboxOfGeometry(t.geometry) });
  const sel=document.getElementById('territorySel');
  while(sel.options.length>1) sel.remove(1);
  TERRITORIES.forEach(t=>{const opt=document.createElement('option'); opt.value=t.id; opt.textContent=t.name||t.id; sel.appendChild(opt)});
}
function onTerritoryChange(){
  const id=document.getElementById('territorySel').value;
  currentTerritory = id ? TERRITORIES.find(t=>t.id===id) : null;
  if(territoryLayer){map.removeLayer(territoryLayer); territoryLayer=null}
  if(currentTerritory){
    territoryLayer=L.geoJSON(currentTerritory.geometry,{style:{color:currentTerritory.color||'#555',weight:1,opacity:0.8,dashArray:'4,6',fillColor:currentTerritory.color||'#555',fillOpacity:0.08},interactive:false,className:'territory-boundary'}).addTo(map);
    const b=currentTerritory.bbox; if(b){const[w,s,e,n]=b; map.fitBounds([[s,w],[n,e]])}
  }
  // Rebuild group list for new territory
  buildGroupList();
  requestAnimationFrame(applyFilters);
  updateTerritoryInsights(); // AI feature
}

/* Filtering */
let baseVisiblePredicate = rec => true;
function updateFilter(){
  const statusSet=new Set(Array.from(document.querySelectorAll('.statusChk')).filter(cb=>cb.checked).map(cb=>cb.value));
  const showStaff = document.getElementById('showStaffChk').checked;
  const groupSel=document.getElementById('groupSel');
  const groupSet=new Set(Array.from(groupSel.selectedOptions).map(o=>o.value));
  const q=(document.getElementById('searchBox').value||'').trim().toLowerCase();
  baseVisiblePredicate=function(rec){
    if(rec.active===false) return false;
    const st = normalizeStatus(rec.Status||rec.status);
    // Handle staff separately
    if(st === 'staff') return showStaff;
    // Check normal statuses
    if(statusSet.size && !statusSet.has(st)) return false;
    if(groupSet.size){const g=(rec.Group||rec.group||'').trim(); if(!groupSet.has(g)) return false;}
    if(q){const hay=((rec.School||rec.SchoolName||rec.Name||'')+' '+(rec.Address||'')+' '+(rec.Group||'')+' '+(rec.Notes||'')).toLowerCase(); if(!hay.includes(q)) return false;}
    return true;
  };
  requestAnimationFrame(()=>{ 
    applyFilters(); 
    if(LIST_ON) updateList(); 
    updateTerritoryInsights(); // Update insights when filters change
  });
}
function territoryVisible(rec){
  if(!currentTerritory) return false;            // show nothing until a territory is selected
  if(!baseVisiblePredicate(rec)) return false;
  if(!Number.isFinite(rec.lat)||!Number.isFinite(rec.lon)) return false;
  if(rec.TerritoryId) return rec.TerritoryId===currentTerritory.id;
  const geo=currentTerritory.geometry, b=currentTerritory.bbox||bboxOfGeometry(geo);
  if(b){const[w,s,e,n]=b; if(rec.lon<w||rec.lon>e||rec.lat<s||rec.lat>n) return false;}
  return pointInGeometry(rec.lon,rec.lat,geo);
}
let visiblePredicate = territoryVisible;
function applyFilters(){
  for (let i=0; i<markers.length; i++){
    const m = markers[i];
    const show = visiblePredicate(m._rec);
    if(show){
      if(!map.hasLayer(m)) m.addTo(map);
      const col=getStatusColor(m._rec);
      m.setStyle({color:col, fillColor:col});
    } else {
      if(map.hasLayer(m)) map.removeLayer(m);
    }
  }
}

/* Popups (status change and notes editing) */
function formatPhone(p){const raw=String(p||'').trim(); if(!raw) return ''; const digits=raw.replace(/[^\d+]/g,''); return `<a href="tel:${digits}">${raw}</a>`}
function formatEmail(e){const raw=String(e||'').trim(); if(!raw) return ''; return `<a href="mailto:${raw}">${raw}</a>`}
function escapeHtml(text){const div=document.createElement('div');div.textContent=text;return div.innerHTML;}
function buildPopupHTML(rec){
  const name=rec.School||rec.SchoolName||rec.Name||rec.LocationName||rec.Location||'Location';
  const addr=rec.Address||rec.address||'';
  const phone=rec.Phone||rec.phone||rec.Telephone||rec['Phone Number']||rec['Contact Phone']||'';
  const email=rec.Email||rec.email||rec['Email Address']||rec['Contact Email']||'';
  const group=(rec.Group||rec.group||'').trim();
  const notes=(rec.Notes||rec.notes||'').trim();
  const st=normalizeStatus(rec.Status||rec.status);
  const phoneHTML=phone?`<br>Phone: ${formatPhone(phone)}`:'';
  const emailHTML=email?`<br>Email: ${formatEmail(email)}`:'';
  const groupHTML=group?`<br>Group: ${escapeHtml(group)}`:'';
  const select = `
    <select data-role="status-select">
      <option value="none"${st==='none'?' selected':''}>None</option>
      <option value="recent"${st==='recent'?' selected':''}>Recent</option>
      <option value="inprogress"${st==='inprogress'?' selected':''}>In Progress</option>
      <option value="current"${st==='current'?' selected':''}>Current</option>
      <option value="staff"${st==='staff'?' selected':''}>Staff</option>
    </select>`;
  const today = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  const notesField = `
    <div style="margin-top:8px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
        <span style="font-weight:600; font-size:12px;">Notes:</span>
        <button data-role="add-timestamp" style="font-size:11px; padding:2px 6px; border-radius:4px;" type="button">+ Add ${today}</button>
      </div>
      <textarea data-role="notes-input" style="width:100%; min-height:50px; padding:4px; font-size:12px; border:1px solid #ddd; border-radius:4px; resize:vertical;" placeholder="Add notes (e.g., Spoke with contact, follow up next week)">${escapeHtml(notes)}</textarea>
      <div style="display:flex; justify-content:space-between; align-items:center; font-size:11px; color:#666; margin-top:2px;">
        <span>Tip: Press Ctrl+Enter to save</span>
        <span data-role="char-count">${notes.length} chars</span>
      </div>
    </div>`;
  const canUpdateKey = !!(rec.Id || ((rec.School||rec.SchoolName||rec.Name||rec.LocationName||rec.Location) && rec.Address));
  const btn = `<button data-role="save-changes" ${canUpdateKey?'':'disabled'} style="width:100%; margin-top:6px;">${canUpdateKey?'Save All Changes':'Save (no key)'}</button>`;
  const tip = canUpdateKey ? '' : `<div class="muted" style="margin-top:4px;">Add an <strong>Id</strong> column or ensure Name & Address exist to enable updates.</div>`;
  return `<div><strong>${escapeHtml(name)}</strong><br>${escapeHtml(addr)}${groupHTML}${phoneHTML}${emailHTML}</div>
          <div class="popup-row">Status: ${select}</div>
          ${notesField}
          ${btn}
          ${tip}`;
}
function addCircleFor(rec){
  const m=L.circleMarker([rec.lat,rec.lon],{radius:6,color:getStatusColor(rec),fillColor:getStatusColor(rec),fillOpacity:0.9,weight:1});
  m._rec=rec;
  m.on('click',()=>{
    const html = buildPopupHTML(rec);
    m.bindPopup(html).openPopup();
    setTimeout(()=>{
      const container = document.querySelector('.leaflet-popup-content');
      const sel = container && container.querySelector('[data-role="status-select"]');
      const notesInput = container && container.querySelector('[data-role="notes-input"]');
      const btn = container && container.querySelector('[data-role="save-changes"]');
      const timestampBtn = container && container.querySelector('[data-role="add-timestamp"]');
      const charCount = container && container.querySelector('[data-role="char-count"]');
      if (!sel || !btn) return;
      
      // Track unsaved changes
      let hasUnsavedChanges = false;
      const checkForChanges = () => {
        const currentSt = sel.value;
        const currentNotes = notesInput ? notesInput.value.trim() : '';
        const originalSt = normalizeStatus(rec.Status||rec.status);
        const originalNotes = (rec.Notes||rec.notes||'').trim();
        
        hasUnsavedChanges = (currentSt !== originalSt || currentNotes !== originalNotes);
        
        if (hasUnsavedChanges) {
          btn.style.background = '#ff7f0e';
          btn.textContent = 'Save Changes*';
        } else {
          btn.style.background = '';
          btn.textContent = 'Save All Changes';
        }
        
        // Update character count
        if (charCount && notesInput) {
          charCount.textContent = `${notesInput.value.length} chars`;
        }
      };
      
      // Monitor changes
      sel.addEventListener('change', checkForChanges);
      if (notesInput) {
        notesInput.addEventListener('input', checkForChanges);
      }
      
      // Add timestamp button handler
      if (timestampBtn && notesInput) {
        timestampBtn.addEventListener('click', () => {
          const today = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          const currentText = notesInput.value;
          const newText = currentText ? `${currentText}\n${today}: ` : `${today}: `;
          notesInput.value = newText;
          notesInput.focus();
          // Move cursor to end
          notesInput.setSelectionRange(newText.length, newText.length);
          checkForChanges();
        });
      }
      
      // Save function
      const saveChanges = async () => {
        const newSt = sel.value;
        const newNotes = notesInput ? notesInput.value.trim() : '';
        const oldSt = normalizeStatus(rec.Status||rec.status);
        const oldNotes = (rec.Notes||rec.notes||'').trim();
        
        // Check if anything changed
        if (newSt === oldSt && newNotes === oldNotes) {
          showToast('No changes to save');
          return;
        }
        
        // Show saving state
        btn.disabled = true;
        btn.textContent = 'Saving...';
        
        // Update local record optimistically
        rec.Status = newSt;
        rec.Notes = newNotes;
        m.setStyle({ color: getStatusColor(rec), fillColor: getStatusColor(rec) });
        
        const keyField = rec.Id ? 'Id' : 'School+Address';
        const keyValue = rec.Id ? String(rec.Id) : JSON.stringify({ 
          School: (rec.School||rec.SchoolName||rec.Name||rec.LocationName||rec.Location||''), 
          Address: (rec.Address||'') 
        });
        
        // Build patch with only changed fields
        const patch = {};
        if (newSt !== oldSt) patch.Status = newSt;
        if (newNotes !== oldNotes) patch.Notes = newNotes;
        
        try{
          const res = await updateRowInSheet({ keyField, keyValue, patch });
          log('saved changes to row '+(res && res.rowNumber ? res.rowNumber : '?'));
          
          // Show what was updated
          const updates = [];
          if (newSt !== oldSt) updates.push('status');
          if (newNotes !== oldNotes) updates.push('notes');
          showToast(`✅ Updated ${updates.join(' and ')}`);
          
          // Refresh popup with new data
          m.setPopupContent(buildPopupHTML(rec));
          
          // Update insights if filters might be affected
          if (newSt !== oldSt) {
            requestAnimationFrame(() => {
              applyFilters();
              updateTerritoryInsights();
            });
          }
        }catch(err){
          log('update FAIL: '+(err && err.message ? err.message : err));
          showToast('❌ Could not save changes, reverting','error');
          // Revert changes
          rec.Status = oldSt;
          rec.Notes = oldNotes;
          m.setStyle({ color: getStatusColor(rec), fillColor: getStatusColor(rec) });
          m.setPopupContent(buildPopupHTML(rec));
        }
      };
      
      // Button click
      btn.addEventListener('click', saveChanges);
      
      // Ctrl+Enter in notes field
      if (notesInput) {
        notesInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            saveChanges();
          }
        });
      }
    },0);
  });
  markers.push(m);
  return m;
}

/* Groups/List - Territory-Aware */
function buildGroupList(){
  const sel=document.getElementById('groupSel'); 
  
  // If no territory selected, show all groups
  if (!currentTerritory) {
    const set=new Set();
    DATA.forEach(r=>{const g=(r.Group||r.group||'').trim(); if(g) set.add(g)});
    GROUPS=Array.from(set).sort();
    sel.innerHTML=''; 
    GROUPS.forEach(g=>{const o=document.createElement('option'); o.value=g; o.textContent=g; sel.appendChild(o)});
    return;
  }
  
  // Filter groups based on current territory
  const set=new Set();
  DATA.forEach(r=>{
    // Check if school is in current territory
    if (!isValidLatLon(r.lat,r.lon)) return;
    
    // Use TerritoryId if available, otherwise check geometry
    let inTerritory = false;
    if (r.TerritoryId || r.territoryId || r.territory_id) {
      inTerritory = (r.TerritoryId || r.territoryId || r.territory_id) === currentTerritory.id;
    } else {
      inTerritory = pointInGeometry(r.lon, r.lat, currentTerritory.geometry);
    }
    
    if (inTerritory) {
      const g=(r.Group||r.group||'').trim(); 
      if(g) set.add(g);
    }
  });
  
  GROUPS=Array.from(set).sort();
  sel.innerHTML=''; 
  
  if (GROUPS.length === 0) {
    const o=document.createElement('option'); 
    o.value=''; 
    o.textContent='-- No groups in this territory --';
    o.disabled = true;
    sel.appendChild(o);
  } else {
    GROUPS.forEach(g=>{
      const o=document.createElement('option'); 
      o.value=g; 
      o.textContent=g; 
      sel.appendChild(o);
    });
  }
  
  // Clear any selected groups that don't exist in new territory
  for(const o of sel.options) {
    if(o.selected && !GROUPS.includes(o.value)) {
      o.selected = false;
    }
  }
}
function updateList(){
  const list=document.getElementById('schoolList'); list.innerHTML='';
  const items=[];
  markers.forEach(m=>{
    const r=m._rec; 
    const st = normalizeStatus(r.Status || r.status);
    // Only show in list if visible and not staff (unless staff toggle is on)
    if(visiblePredicate(r)) {
      items.push({
        name:r.School||r.SchoolName||r.Name||r.LocationName||r.Location||'Location',
        addr:r.Address||'',
        lat:r.lat,
        lon:r.lon,
        m
      });
    }
  });
  items.sort((a,b)=>a.name.localeCompare(b.name));
  items.forEach(it=>{
    const d=document.createElement('div'); 
    d.className='list-item'; 
    d.innerHTML=`<strong>${it.name}</strong><br><span class="muted">${it.addr}</span>`; 
    d.addEventListener('click',()=>{map.setView([it.lat,it.lon],14); it.m.fire('click')}); 
    list.appendChild(d);
  });
}

/* Downloads */
function toCSV(rows, header){
  const esc=v=>'"'+String(v==null?'':v).replace(/"/g,'""')+'"';
  // Ensure Notes column is included if it exists in data but not header
  const hasNotes = rows.some(r => r.Notes !== undefined || r.notes !== undefined);
  const finalHeader = [...header];
  if (hasNotes && !header.includes('Notes') && !header.includes('notes')) {
    finalHeader.push('Notes');
  }
  const lines=[finalHeader.map(esc).join(',')];
  rows.forEach(r=>lines.push(finalHeader.map(h=>esc(r[h])).join(',')));
  return lines.join('\n');
}
function download(filename, text){
  const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  requestAnimationFrame(()=>{
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
}

/* Server call: update status and/or notes */
async function updateRowInSheet({ keyField, keyValue, patch }){
  const res = await fetchWithTimeout(WRITE_ENDPOINT, {
    method: 'POST',
    headers: { 'Content-Type':'text/plain;charset=utf-8' },
    body: JSON.stringify({ secret: WRITE_SECRET, mode:'update', sheetName: SHEET_TAB_NAME, keyField, keyValue, patch }),
    cache: 'no-store', redirect: 'follow'
  }, 15000);
  const text = await res.text();
  let json={}; try{ json=JSON.parse(text);}catch(e){ log('update non-JSON body: '+text.slice(0,200)); }
  if (!res.ok || !json.ok){
    log(`update FAIL http=${res.status} body=${text.slice(0,240)}`);
    throw new Error((json && json.error) || ('HTTP '+res.status));
  }
  return json;
}

/* ===== AI FEATURES ===== */

// AI Assistant functionality
class AIAssistant {
  constructor() {
    this.context = {
      totalSchools: 0,
      territories: [],
      currentTerritory: null,
      statusDistribution: {}
    };
  }

  updateContext() {
    this.context.totalSchools = DATA.filter(r => normalizeStatus(r.Status || r.status) !== 'staff').length;
    this.context.territories = TERRITORIES.map(t => t.name);
    this.context.currentTerritory = currentTerritory?.name;
    
    // Get selected groups
    const groupSel = document.getElementById('groupSel');
    this.context.selectedGroups = Array.from(groupSel.selectedOptions).map(o => o.value);
    
    // Calculate status distribution for visible schools (excluding staff)
    const dist = {none:0, recent:0, inprogress:0, current:0};
    const visible = markers.filter(m => {
      const st = normalizeStatus(m._rec.Status || m._rec.status);
      if (st === 'staff') return false; // Exclude staff
      if (currentTerritory) return territoryVisible(m._rec);
      return baseVisiblePredicate(m._rec);
    });
    
    visible.forEach(m => {
      const st = normalizeStatus(m._rec.Status || m._rec.status);
      if (st !== 'staff') dist[st]++;
    });
    this.context.statusDistribution = dist;
    this.context.visibleSchools = visible.length;
  }

  async processQuery(query) {
    this.updateContext();
    
    // Build context string
    let contextStr = this.context.currentTerritory || 'all territories';
    if (this.context.selectedGroups.length > 0) {
      contextStr += ` (${this.context.selectedGroups.join(', ')})`;
    }
    
    // Simple pattern matching for common queries
    const lowerQuery = query.toLowerCase();
    
    if (lowerQuery.includes('how many')) {
      return `There are ${this.context.totalSchools} locations total (excluding staff). Currently showing ${this.context.visibleSchools} locations in ${contextStr}.`;
    }
    
    if (lowerQuery.includes('status') || lowerQuery.includes('breakdown')) {
      const dist = this.context.statusDistribution;
      return `Status breakdown for ${contextStr}:\n• None: ${dist.none}\n• Recent: ${dist.recent}\n• In Progress: ${dist.inprogress}\n• Current: ${dist.current}\n(Staff excluded from counts)`;
    }
    
    if (lowerQuery.includes('group') && this.context.selectedGroups.length > 0) {
      const groups = this.context.selectedGroups;
      const groupData = markers.filter(m => {
        const g = (m._rec.Group || m._rec.group || '').trim();
        return groups.includes(g) && (currentTerritory ? territoryVisible(m._rec) : baseVisiblePredicate(m._rec));
      });
      return `Selected group(s): ${groups.join(', ')}\nSchools in selection: ${groupData.length}\nThis represents ${Math.round(groupData.length/this.context.visibleSchools*100)}% of visible schools in ${this.context.currentTerritory || 'the current view'}.`;
    }
    
    if (lowerQuery.includes('territory') && lowerQuery.includes('most')) {
      const territoryCounts = {};
      TERRITORIES.forEach(t => {
        const count = DATA.filter(r => {
          if (!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) return false;
          return pointInGeometry(r.lon, r.lat, t.geometry);
        }).length;
        territoryCounts[t.name] = count;
      });
      const sorted = Object.entries(territoryCounts).sort((a,b) => b[1] - a[1]);
      return `Territories by school count:\n${sorted.slice(0,5).map(([name,count]) => `• ${name}: ${count} schools`).join('\n')}`;
    }
    
    if (lowerQuery.includes('recommend') || lowerQuery.includes('suggest')) {
      return this.generateRecommendation();
    }
    
    // Default response
    return `I can help you with:\n• Location counts and statistics\n• Territory analysis\n• Group-specific insights\n• Status breakdowns\n• Strategic recommendations\n\nCurrent context: ${contextStr}\n\nTip: Click any location marker to update status and add/edit notes directly!\n\nWhat would you like to know?`;
  }

  generateRecommendation() {
    const visible = markers.filter(m => {
      const st = normalizeStatus(m._rec.Status || m._rec.status);
      if (st === 'staff') return false; // Exclude staff
      if (currentTerritory) return territoryVisible(m._rec);
      return baseVisiblePredicate(m._rec) && st !== 'staff';
    });
    const noneCount = visible.filter(m => normalizeStatus(m._rec.Status) === 'none').length;
    const inProgressCount = visible.filter(m => normalizeStatus(m._rec.Status) === 'inprogress').length;
    
    // Build context for recommendations
    let context = '';
    if (this.context.selectedGroups.length > 0) {
      context = ` for ${this.context.selectedGroups.join(', ')}`;
    }
    if (this.context.currentTerritory) {
      context += ` in ${this.context.currentTerritory}`;
    }
    
    if (visible.length === 0) {
      return `📊 No locations found${context}. Try adjusting your filters or selecting a different territory/group.`;
    }
    
    if (inProgressCount > visible.length * 0.2) {
      return `📊 Recommendation: Focus on closing deals${context}. You have ${inProgressCount} locations (${Math.round(inProgressCount/visible.length*100)}%) in progress. Schedule follow-ups to convert them to current clients.`;
    }
    
    if (noneCount > visible.length * 0.5) {
      return `📊 Recommendation: Focus on converting uncontacted locations${context}. You have ${noneCount} uncontacted locations (${Math.round(noneCount/visible.length*100)}%) in the current view. Consider prioritizing clusters for efficient outreach.`;
    }
    
    const recentCount = visible.filter(m => normalizeStatus(m._rec.Status) === 'recent').length;
    if (recentCount > visible.length * 0.3) {
      return `📊 Recommendation: Move recent contacts to "In Progress"${context}. You have ${recentCount} locations (${Math.round(recentCount/visible.length*100)}%) that were recently contacted. Follow up to advance these opportunities.`;
    }
    
    return `📊 Recommendation: Your coverage${context} looks good! Consider expanding to adjacent areas or deepening relationships with current clients.`;
  }
}

const aiAssistant = new AIAssistant();

// AI Natural Language Search
function performAISearch(query) {
  const lowerQuery = query.toLowerCase();
  const results = [];
  
  DATA.forEach(rec => {
    let score = 0;
    const name = (rec.School || rec.SchoolName || rec.Name || rec.LocationName || rec.Location || '').toLowerCase();
    const address = (rec.Address || '').toLowerCase();
    const group = (rec.Group || '').toLowerCase();
    const notes = (rec.Notes || '').toLowerCase();
    
    // Check for exact matches
    if (name.includes(lowerQuery)) score += 10;
    if (address.includes(lowerQuery)) score += 5;
    if (group.includes(lowerQuery)) score += 3;
    if (notes.includes(lowerQuery)) score += 4;
    
    // Check for individual words
    const words = lowerQuery.split(' ');
    words.forEach(word => {
      if (word.length > 2) {
        if (name.includes(word)) score += 2;
        if (address.includes(word)) score += 1;
        if (notes.includes(word)) score += 1;
      }
    });
    
    // Status-based queries
    if (lowerQuery.includes('uncontacted') && normalizeStatus(rec.Status) === 'none') score += 8;
    if (lowerQuery.includes('recent') && normalizeStatus(rec.Status) === 'recent') score += 8;
    if (lowerQuery.includes('in progress') && normalizeStatus(rec.Status) === 'inprogress') score += 8;
    if (lowerQuery.includes('current') && normalizeStatus(rec.Status) === 'current') score += 8;
    if (lowerQuery.includes('staff') && normalizeStatus(rec.Status) === 'staff') score += 8;
    
    // Notes-specific queries
    if (lowerQuery.includes('with notes') && notes.length > 0) score += 6;
    if (lowerQuery.includes('email') && notes.includes('email')) score += 5;
    if (lowerQuery.includes('contacted') && notes.length > 0) score += 4;
    
    if (score > 0) {
      results.push({rec, score});
    }
  });
  
  results.sort((a,b) => b.score - a.score);
  return results.slice(0, 10).map(r => r.rec);
}

// Territory Insights
function updateTerritoryInsights() {
  // Highlight the insights panel briefly to show it updated
  const panel = document.getElementById('insightsPanel');
  const header = document.getElementById('insightsHeader');
  panel.classList.add('highlighted');
  header.classList.add('has-update');
  setTimeout(() => {
    panel.classList.remove('highlighted');
    header.classList.remove('has-update');
  }, 1500);
  
  // Get selected groups
  const groupSel = document.getElementById('groupSel');
  const selectedGroups = Array.from(groupSel.selectedOptions).map(o => o.value);
  const hasGroupFilter = selectedGroups.length > 0;
  
  if (!currentTerritory && !hasGroupFilter) {
    document.getElementById('territoryStats').innerHTML = '<div class="muted">Select a territory or group to see insights</div>';
    document.getElementById('aiRecommendations').innerHTML = '<div class="muted">Insights will appear here</div>';
    return;
  }
  
  // Filter markers based on current filters (territory + groups + status)
  // EXCLUDE STAFF from metrics
  const visible = markers.filter(m => {
    const st = normalizeStatus(m._rec.Status || m._rec.status);
    if (st === 'staff') return false; // Exclude staff from insights
    
    // Use the full filter predicate to respect all current filters
    if (currentTerritory) {
      return territoryVisible(m._rec);
    } else {
      return baseVisiblePredicate(m._rec) && st !== 'staff';
    }
  });
  
  // Also count staff separately
  const staffCount = markers.filter(m => {
    const st = normalizeStatus(m._rec.Status || m._rec.status);
    if (st !== 'staff') return false;
    if (currentTerritory) {
      return territoryVisible(m._rec);
    } else {
      return baseVisiblePredicate(m._rec);
    }
  }).length;
  
  const statusCounts = {none:0, recent:0, inprogress:0, current:0};
  const groupCounts = {};
  
  visible.forEach(m => {
    const st = normalizeStatus(m._rec.Status || m._rec.status);
    if (st !== 'staff') { // Double-check staff exclusion
      statusCounts[st]++;
    }
    
    const group = (m._rec.Group || m._rec.group || 'No Group').trim();
    groupCounts[group] = (groupCounts[group] || 0) + 1;
  });
  
  const total = visible.length; // Already excludes staff
  const coverage = total > 0 ? Math.round(statusCounts.current / total * 100) : 0;
  const inProgressRate = total > 0 ? Math.round(statusCounts.inprogress / total * 100) : 0;
  
  // Build context label
  let contextLabel = '';
  if (currentTerritory && hasGroupFilter) {
    contextLabel = `<div style="font-weight:600; color:#6a1b9a; margin-bottom:8px;">
      ${currentTerritory.name} - ${selectedGroups.join(', ')}
    </div>`;
  } else if (currentTerritory) {
    contextLabel = `<div style="font-weight:600; color:#6a1b9a; margin-bottom:8px;">
      ${currentTerritory.name} - All Groups
    </div>`;
  } else if (hasGroupFilter) {
    contextLabel = `<div style="font-weight:600; color:#6a1b9a; margin-bottom:8px;">
      All Territories - ${selectedGroups.join(', ')}
    </div>`;
  }
  
  // Update stats display
  document.getElementById('territoryStats').innerHTML = `
    ${contextLabel}
    <div class="ai-stat"><span>Total Locations (excl. staff):</span><strong>${total}</strong></div>
    <div class="ai-stat"><span>Coverage Rate:</span><strong>${coverage}%</strong></div>
    <div class="ai-stat"><span>In Progress Rate:</span><strong>${inProgressRate}%</strong></div>
    <div style="margin-top:8px; padding-top:8px; border-top:1px solid #e0e0e0;">
      <div class="ai-stat"><span>Uncontacted:</span><strong>${statusCounts.none}</strong></div>
      <div class="ai-stat"><span>Recent:</span><strong>${statusCounts.recent}</strong></div>
      <div class="ai-stat"><span>In Progress:</span><strong>${statusCounts.inprogress}</strong></div>
      <div class="ai-stat"><span>Current Clients:</span><strong>${statusCounts.current}</strong></div>
      <div class="ai-stat" style="opacity:0.6;"><span>Staff (excluded):</span><strong>${staffCount}</strong></div>
    </div>
    ${hasGroupFilter && Object.keys(groupCounts).length > 0 ? 
      `<div style="margin-top:8px; padding-top:8px; border-top:1px solid #e0e0e0;">
        <strong>Group Breakdown:</strong><br>
        ${Object.entries(groupCounts).map(([g,c]) => 
          `<div class="ai-stat"><span>${g}:</span><strong>${c}</strong></div>`
        ).join('')}
      </div>` : ''}
  `;
  
  // Generate AI recommendations based on context (excluding staff)
  let recommendations = [];
  
  if (total === 0) {
    recommendations.push(`No non-staff schools found. Try adjusting your filters.`);
  } else {
    if (statusCounts.inprogress > 0) {
      const pct = Math.round(statusCounts.inprogress / total * 100);
      recommendations.push(`${statusCounts.inprogress} schools in progress (${pct}%) - focus on closing`);
    }
    if (statusCounts.none > total * 0.4) {
      recommendations.push(`High opportunity: ${statusCounts.none} uncontacted schools${hasGroupFilter ? ' in selected group(s)' : ''}`);
    }
    if (statusCounts.recent > 5) {
      recommendations.push(`Move ${statusCounts.recent} recent contacts to "In Progress"`);
    }
    if (coverage < 30) {
      recommendations.push(`Low coverage (${coverage}%) - prioritize for growth`);
    } else if (coverage > 70) {
      recommendations.push(`Strong coverage (${coverage}%) - focus on retention`);
    }
    
    // Group-specific recommendations
    if (hasGroupFilter && selectedGroups.length === 1) {
      const groupName = selectedGroups[0];
      if (statusCounts.none > 0) {
        recommendations.push(`Target ${statusCounts.none} uncontacted ${groupName} schools`);
      }
      if (statusCounts.inprogress > statusCounts.current) {
        recommendations.push(`Good pipeline: More schools in progress than current`);
      }
    }
    
    if (recommendations.length === 0) {
      recommendations.push(`Balanced ${hasGroupFilter ? 'group' : 'territory'} - maintain current strategy`);
    }
  }
  
  document.getElementById('aiRecommendations').innerHTML = recommendations
    .map(r => `<div class="ai-recommendation">${r}</div>`)
    .join('');
}

// Generate AI Report
async function generateAIReport() {
  const report = [];
  report.push(`📊 **Territory Analysis Report**`);
  report.push(`Generated: ${new Date().toLocaleDateString()}\n`);
  
  // Overall statistics (excluding staff)
  const nonStaffData = DATA.filter(r => normalizeStatus(r.Status || r.status) !== 'staff');
  const staffData = DATA.filter(r => normalizeStatus(r.Status || r.status) === 'staff');
  
  report.push(`**Overall Statistics:**`);
  report.push(`• Total Locations: ${nonStaffData.length} (+ ${staffData.length} staff excluded)`);
  report.push(`• Active Territories: ${TERRITORIES.length}`);
  
  // Count schools with notes
  const withNotes = nonStaffData.filter(r => (r.Notes || r.notes || '').trim().length > 0).length;
  report.push(`• Locations with notes: ${withNotes} (${Math.round(withNotes/nonStaffData.length*100)}%)`);
  
  // Status breakdown (excluding staff)
  const statusDist = {none:0, recent:0, inprogress:0, current:0};
  nonStaffData.forEach(r => {
    const st = normalizeStatus(r.Status || r.status);
    if (st !== 'staff') statusDist[st]++;
  });
  
  report.push(`\n**Status Distribution (excluding staff):**`);
  report.push(`• Uncontacted: ${statusDist.none} (${Math.round(statusDist.none/nonStaffData.length*100)}%)`);
  report.push(`• Recent: ${statusDist.recent} (${Math.round(statusDist.recent/nonStaffData.length*100)}%)`);
  report.push(`• In Progress: ${statusDist.inprogress} (${Math.round(statusDist.inprogress/nonStaffData.length*100)}%)`);
  report.push(`• Current Clients: ${statusDist.current} (${Math.round(statusDist.current/nonStaffData.length*100)}%)`);
  
  // Coverage rate
  const coverageRate = Math.round(statusDist.current / nonStaffData.length * 100);
  report.push(`\n**Coverage Rate: ${coverageRate}%**`);
  
  // Territory analysis
  report.push(`\n**Top Territories by Location Count:**`);
  const territoryData = [];
  TERRITORIES.forEach(t => {
    const count = nonStaffData.filter(r => {
      if (!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) return false;
      return pointInGeometry(r.lon, r.lat, t.geometry);
    }).length;
    territoryData.push({name: t.name, count});
  });
  territoryData.sort((a,b) => b.count - a.count);
  territoryData.slice(0,5).forEach(t => {
    report.push(`• ${t.name}: ${t.count} locations`);
  });
  
  // Recommendations
  report.push(`\n**Strategic Recommendations:**`);
  if (statusDist.inprogress > nonStaffData.length * 0.1) {
    report.push(`• Strong pipeline: ${statusDist.inprogress} locations in progress - focus on closing`);
  }
  if (statusDist.none > nonStaffData.length * 0.3) {
    report.push(`• High growth opportunity with ${statusDist.none} uncontacted locations`);
  }
  if (statusDist.recent > nonStaffData.length * 0.15) {
    report.push(`• Move ${statusDist.recent} recent contacts to "In Progress"`);
  }
  if (withNotes < nonStaffData.length * 0.3) {
    report.push(`• Improve documentation: Only ${Math.round(withNotes/nonStaffData.length*100)}% of locations have notes`);
  }
  report.push(`• Focus on territories with highest uncontacted density`);
  report.push(`• Implement cluster-based outreach for efficiency`);
  
  return report.join('\n');
}

/* Init */
async function init(){
  log('init → territories');
  await loadTerritories();

  const params = new URLSearchParams(location.search);
  const file   = (params.get('file')||'').replace(/[^a-z0-9._-]/gi,'');
  let csvUrl   = SHEETS_ENDPOINT;
  if (file) csvUrl += (csvUrl.includes('?') ? '&' : '?') + 'file=' + file;
  const host = new URL(csvUrl, location.href).host;
  if (!/googleusercontent\.com$/i.test(host) && !/script\.google\.com$/i.test(host)) {
    csvUrl += (csvUrl.includes('?') ? '&' : '?') + 'v=' + Date.now();
  }

  log('init → fetch CSV');
  const res  = await fetchWithTimeout(csvUrl, { cache: 'no-store', redirect: 'follow' }, 15000);
  if (!res.ok) throw new Error(`CSV HTTP ${res.status}`);
  const text = await res.text();

  const parsed=parseCSV(text); HEADER=parsed.header; DATA=parsed.rows; normalizeRecords(DATA);
  buildGroupList();

  log('init → create markers');
  for (let i=0;i<DATA.length;i++){
    const r=DATA[i];
    if(isValidLatLon(r.lat,r.lon)){
      const m = addCircleFor(r);
      if (visiblePredicate(r)) m.addTo(map);
    }
  }
  
  // Initialize insights (will show "select territory" message initially)
  updateTerritoryInsights();
  
  log('init ← done');
}

/* Wire UI */
document.addEventListener('DOMContentLoaded',()=>{
  init().catch(e=>{console.error(e); showToast('Data load error: '+e.message, 'error'); log('ERR '+e.message)});

  // Original event listeners
  document.getElementById('territorySel').addEventListener('change', onTerritoryChange);
  document.getElementById('groupSel').addEventListener('change', updateFilter);
  document.querySelectorAll('.statusChk').forEach(cb=>cb.addEventListener('change', updateFilter));
  document.getElementById('showStaffChk').addEventListener('change', updateFilter);
  document.getElementById('btnSearch').addEventListener('click', updateFilter);
  document.getElementById('btnClearSearch').addEventListener('click',()=>{document.getElementById('searchBox').value=''; updateFilter()});
  document.getElementById('searchBox').addEventListener('keydown',e=>{if(e.key==='Enter') updateFilter()});
  document.getElementById('btnZoomFirst').addEventListener('click',()=>{const first=markers.find(m=>map.hasLayer(m)); if(first) map.setView(first.getLatLng(),14)});

  document.getElementById('btnToggleList').addEventListener('click',()=>{
    LIST_ON=!LIST_ON;
    document.getElementById('listContainer').style.display=LIST_ON?'block':'none';
    document.getElementById('btnToggleList').textContent=LIST_ON?'List View: ON':'List View: OFF';
    if(LIST_ON) updateList();
  });
  document.getElementById('groupSelectAll').addEventListener('click',()=>{
    const s=document.getElementById('groupSel'); 
    for(const o of s.options) o.selected=true; 
    updateFilter();
  });
  
  document.getElementById('groupClear').addEventListener('click',()=>{
    const s=document.getElementById('groupSel'); 
    for(const o of s.options) o.selected=false; 
    updateFilter();
  });

  // CSV downloads
  document.getElementById('btnDownloadAll').addEventListener('click', ()=>{
    const csv = toCSV(DATA, HEADER);
    const d   = new Date().toISOString().slice(0,10);
    download(`territory-data-all-${d}.csv`, csv);
  });

  document.getElementById('btnDownloadFiltered').addEventListener('click', ()=>{
    const filtered = DATA.filter(r => visiblePredicate(r));
    const csv = toCSV(filtered, HEADER);
    const d   = new Date().toISOString().slice(0,10);
    download(`territory-data-filtered-${d}.csv`, csv);
  });

  // Tab switching (only for 2 tabs now)
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById(`${tab.dataset.tab}-content`).classList.add('active');
    });
  });

  // Insights panel collapse
  document.getElementById('btnCollapseInsights').addEventListener('click', () => {
    const panel = document.getElementById('insightsPanel');
    const btn = document.getElementById('btnCollapseInsights');
    const isCollapsed = panel.classList.contains('is-collapsed');
    panel.classList.toggle('is-collapsed');
    btn.textContent = isCollapsed ? 'Collapse' : 'Expand';
  });

  // AI Panel controls
  document.getElementById('btnToggleAI').addEventListener('click', () => {
    document.getElementById('aiPanel').classList.toggle('active');
  });
  
  document.getElementById('btnOpenAI').addEventListener('click', () => {
    document.getElementById('aiPanel').classList.add('active');
  });
  
  document.getElementById('btnCloseAI').addEventListener('click', () => {
    document.getElementById('aiPanel').classList.remove('active');
  });

  // AI Chat
  const sendAIMessage = async () => {
    const input = document.getElementById('aiInput');
    const query = input.value.trim();
    if (!query) return;
    
    const chat = document.getElementById('aiChat');
    chat.innerHTML += `<div class="ai-message user">${query}</div>`;
    input.value = '';
    
    const response = await aiAssistant.processQuery(query);
    chat.innerHTML += `<div class="ai-message assistant">${response}</div>`;
    chat.scrollTop = chat.scrollHeight;
  };
  
  document.getElementById('aiSend').addEventListener('click', sendAIMessage);
  document.getElementById('aiInput').addEventListener('keydown', e => {
    if (e.key === 'Enter') sendAIMessage();
  });

  // AI Search (Advanced keyword search)
  document.getElementById('btnAISearch').addEventListener('click', () => {
    const query = document.getElementById('aiSearchBox').value.trim();
    if (!query) return;
    
    const results = performAISearch(query);
    if (results.length === 0) {
      showToast('No results found for: ' + query, 'error');
      return;
    }
    
    // Apply search results as filter
    const resultIds = new Set(results.map(r => r.Id || `${r.School}_${r.Address}`));
    baseVisiblePredicate = function(rec) {
      const recId = rec.Id || `${rec.School}_${rec.Address}`;
      return resultIds.has(recId);
    };
    applyFilters();
    
    showToast(`Found ${results.length} results for "${query}"`);
    
    // Zoom to first result
    const first = markers.find(m => results.includes(m._rec));
    if (first) map.setView(first.getLatLng(), 12);
  });

  // AI Analysis buttons
  document.getElementById('btnAnalyzeTerritory').addEventListener('click', () => {
    const groupSel = document.getElementById('groupSel');
    const hasGroups = groupSel.selectedOptions.length > 0;
    
    if (!currentTerritory && !hasGroups) {
      showToast('Please select a territory or group first', 'error');
      return;
    }
    
    // Just update insights and highlight the panel
    updateTerritoryInsights();
    showToast('Analysis complete - check Live Insights panel');
  });

  document.getElementById('btnPredictGrowth').addEventListener('click', () => {
    const visible = markers.filter(m => {
      const st = normalizeStatus(m._rec.Status || m._rec.status);
      if (st === 'staff') return false; // Exclude staff from predictions
      if (currentTerritory) return territoryVisible(m._rec);
      return baseVisiblePredicate(m._rec) && st !== 'staff';
    });
    const noneCount = visible.filter(m => normalizeStatus(m._rec.Status) === 'none').length;
    const inProgressCount = visible.filter(m => normalizeStatus(m._rec.Status) === 'inprogress').length;
    const recentCount = visible.filter(m => normalizeStatus(m._rec.Status) === 'recent').length;
    const growthPotential = visible.length > 0 ? Math.round((noneCount + recentCount) / visible.length * 100) : 0;
    
    // Build context
    const groupSel = document.getElementById('groupSel');
    const selectedGroups = Array.from(groupSel.selectedOptions).map(o => o.value);
    let context = '';
    if (selectedGroups.length > 0) {
      context = ` for ${selectedGroups.join(', ')}`;
    }
    if (currentTerritory) {
      context += ` in ${currentTerritory.name}`;
    }
    
    const prediction = `📈 Growth Prediction${context}:

Current Pipeline (excluding staff):
• ${inProgressCount} locations in progress (likely to close)
• ${recentCount} recent contacts (warm leads)
• ${noneCount} uncontacted locations (cold prospects)

Growth potential: ${growthPotential}% (${noneCount + recentCount} convertible locations)

Projected outcomes:
• Short-term (In Progress → Current): ${Math.round(inProgressCount * 0.7)} likely conversions
• Medium-term (Recent → Current): ${Math.round(recentCount * 0.4)} potential conversions
• Long-term (None → Current): ${Math.round(noneCount * 0.2)} new acquisitions

Total projected growth: ${Math.round(inProgressCount * 0.7 + recentCount * 0.4 + noneCount * 0.2)} new clients

Recommended focus: ${inProgressCount > 5 ? 'Close in-progress deals first' : growthPotential > 40 ? 'High growth territory - increase outreach' : growthPotential > 20 ? 'Moderate opportunity - nurture warm leads' : 'Maintenance mode - focus on retention'}`;
    
    // Show in AI chat
    document.getElementById('aiPanel').classList.add('active');
    const chat = document.getElementById('aiChat');
    chat.innerHTML += `<div class="ai-message assistant">${prediction}</div>`;
    chat.scrollTop = chat.scrollHeight;
  });

  document.getElementById('btnGenerateReport').addEventListener('click', async () => {
    const report = await generateAIReport();
    
    // Create and download report
    const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ai-report-${new Date().toISOString().slice(0,10)}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showToast('AI Report generated and downloaded');
  });
});
</script>
</body>
</html>